## 도커의 핵심 목표

도커는 애플리케이션과 그 실행 환경(라이브러리, 종속성 등)을 하나의 패키지인 **컨테이너**로 묶어줌. 이 컨테이너는 어떤 환경에서든 동일하게 작동하도록 보장하는 것이 핵심.

## Docker 플랫폼

- Docker는 애플리케이션을 **컨테이너(container)** 라는 격리된 환경에서 실행한다.
- 컨테이너는 가볍고, 실행에 필요한 모든 것을 포함한다.
- 같은 호스트에서 여러 컨테이너를 동시에 실행 가능하며, 누구와 공유하든 동일하게 동작한다.

Docker는 컨테이너 생명주기를 관리하기 위한 툴을 제공한다:

1. 개발 환경에서 컨테이너로 앱 개발
2. 배포 단위로 컨테이너 활용 (테스트/배포 공통 단위)
3. 프로덕션에 배포 (로컬, 클라우드, 하이브리드 어디든 동일)

---

## Docker 활용 사례

### 빠르고 일관된 앱 배포

- 표준화된 로컬 컨테이너 환경 → CI/CD 파이프라인에 적합
- 개발자가 컨테이너로 코드 공유 → 테스트 환경 배포 → 자동/수동 테스트 → 수정 → 배포까지 단순화

### 유연한 배포와 스케일링

- 컨테이너는 이식성이 뛰어나, 로컬, 데이터센터, 클라우드 어디서든 실행 가능
- 필요에 따라 컨테이너 수를 쉽게 늘리거나 줄임

### 동일 하드웨어에서 더 많은 워크로드

- VM보다 가볍고 빠르며, 서버 자원 활용도를 극대화

---

## Docker 아키텍처

- **클라이언트/서버 구조**
    - Docker client (`docker`) → Docker daemon (`dockerd`)와 REST API로 통신
    - Docker Compose → 여러 컨테이너 앱 관리
- **Docker Daemon**: 컨테이너, 이미지, 네트워크, 볼륨 관리
- **Docker Client**: `docker run`, `docker ps` 같은 명령어 인터페이스
- **Docker Desktop**: 데스크톱 통합 환경 (daemon, client, Compose, Kubernetes 포함)
- **Docker Registry**: 이미지 저장소 (기본 = Docker Hub, 개인 레지스트리 가능)

---

## Docker 객체

- **Image**: 컨테이너 생성 템플릿 (Dockerfile 기반, 레이어 구조)
- **Container**: 이미지의 실행 인스턴스 (시작/중지/이동/삭제 가능, 기본적으로 격리)
- **Network, Volume 등**: 컨테이너 간 통신/데이터 영속화를 위한 객체들

### 예시

```bash
docker run -it ubuntu /bin/bash
```

1. 로컬에 이미지 없으면 Docker Hub에서 pull
2. 컨테이너 생성 → 파일시스템 할당
3. 네트워크 인터페이스 생성 → IP 부여
4. `/bin/bash` 실행 → 터미널과 상호작용 가능
5. `exit` 입력 시 컨테이너 중지 (삭제는 아님)

---

## 기술적 기반

- Docker는 Go 언어로 작성됨
- Linux 커널의 **namespace** 기능을 활용해 격리된 실행 환경 제공
- 각 컨테이너는 별도의 namespace에서 실행 → 독립성 확보

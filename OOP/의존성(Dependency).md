## 의존성(Dependency)란?

A객체가 B객체에게 “give me the money”라는 문맥을 가지는 메시지를 보냈을 때

B객체가 A객체가 보낸 메시지를 처리할 수 있다라는 사실을 알고 있는 지식(정보)를 의존성이라고 말한다.

알고 있는 지식의 수준에 따라서 높은 의존성(강한 결합도), 낮은 의존성(느슨한 결합도)라고 표현하기도 한다.

![image](https://github.com/jeongye01/TIL/assets/74299317/0b6d1a97-6caf-4f80-9dac-f2d8b135d43e)


## Coupling: 강한 결합도, 낮은 결합도

의존성 관계가 높을수록 강한 결합도라고 이야기하고 낮을수록 느슨한 결합도라고 표현한다.

여기서 결합도(Coupling)란, B객체에 변경이 발생하는 경우, B객체를 의존하고 있는 다른 객체들에게 전이되는 정도의 수준을 표현한 것이라고 보면 된다.

실생활을 예로 들면, 지노는 IT 개발자 이지만, 아직도 통신/수도/전기 관련 고지서를 우편으로 받고 있다. 그런데 지노는 2월에 이사를 가게 되었다. 3월 부터 제대로된 고지서를 받고 싶다면 지노는 통신/수도/전기 관련 업체에 전화 또는 이메일로 변경되는 주소를 전달해서 받는 주소를 변경할 수 있도록 이야기 해야 한다.

이렇게 강한 결합도를 가지는 구조는 변경의 여파가 의존하고 있는 모든 객체에게 전파되고 개발자는 변경이라는 전염병에 걸린 객체를 치료해줘야 한다. 하지만 개발자도 사람인지라, 놓친 부분이 생겨서 개발자는 밤마다 수정하고 Hotfix를 적용하는 하루를 살아간다. 

그래서 우리는 워라밸이 있는 개발자가 되기 위해 느슨한 결합도를 유지하기 위해서 아래와 같은 목표를 가져야 한다.

- 올바른 의존성 주입
- 변경을 방해하는 의존성을 제거

## 올바른 의존성 관계 형성

### Constructor 함수를 통한 의존 관계 형성

- 언제? Default 방식
- 의존하는 객체의 전체적인 행동에 대해서 지속적으로 의존 객체에게 메시지를 보내야 하는 경우에 사용하는 것이 좋으며, 기본적으로 사용하는 방식이며 Spring 팀에서 공식적으로 권고하는 방식이다.
    
    ```java
    @Service
    public class MemberRegisterService{
      private MemberDto memberDao;
      
      @Autowired
      public MemberRegisterService(MemberDao memberDao){
        this.memberDao = memberDao;
      }
      
      public ArrayList<Member> getAllMember(){
        return memberDao.selectAll();
      }
    }
    ```
    
- 왜 의존성을 constructor을 통해서 주입해야 하지?
    - 객체의 불변성 확보
    - 테스트 코드의 작성
    - final 키워드 작성 및 Lombok과의 결합
    - 스프링에 비침투적인 코드 작성
    - 순환 참조 에러 방지

### Parameter of Method를 통한 의존 관계 형성

- 생성자 방식과 반대로, 메서드가 실행되는 동안에만 일시적으로 관계를 맺어도 무방할때 사용하는 것이 좋다.
- 메서드가 실행될때 마다 의존 대상이 매번 달라져야 하는 경우에도 유용하다.
- Setter 방식과의 차이점은 특정함수(Setter) 호출해서 의존관계를 맺는 것이 아니라, 단순히 인자로 전달한다는 점이 다르다.

### Setter 함수를 통한 의존관계 형성

- 의존하고 있는 대상을 변경할 수 있는 가능성을 열어두고 싶을때 사용하면 좋다.
- 의존관계를 맺지 않은 상태에서 의존 대상에게 메시지를 요청하게 되면 NPE(Null Point Exception)이 발생하여 Application에 치명적인 오류를 일으켜 정상 동작을 못하게 할 수도 있기 때문에 설계 시, 이 부분을 주의해야 한다.
    
    ```java
    
    public class MemberRegisterService{
      private MemberDto memberDao;
      
    
      public setMemberDao(MemberDao memberDao){
        this.memberDao = memberDao;
      }
      
      public ArrayList<Member> getAllMember(){
        return memberDao.selectAll();
      }
    }
    ```
    

## 변경을 방해하는 의존성 관계

“변경을 방해”한다라는 의미는 변경에 따른 영향이 전파 되는 범위가 너무 커서 변경을 할 수 없는 상황을 이야기한다. 실무에서는 이런 상황을 흔히 레거시하다고 표현한다.

### 변경을 방해하는 의존성 주입 방식

- Constructor 함수에서 new 키워드를 사용하여 구현체를 직접 할당하는 방식은 올바르지 않다. 구현부에 숨겨져 있어서 독자 입장에서는 찾기가 힘들수도 있고, 구현체에 직접적으로 의존하는 것은 변경을 방해하는 시작점이기 때문이다.
    - 그렇다면 무조건 나쁜 것인가?
        - 개발 세상에는 100%는 없지만, 표준 클래스(변경될 확률이 지극히 낮기 때문에) 또는 Default로 할당이 필요한 경우는 생성자 체이닝을 이용해서 직접 할당하는 방식을 가끔 채택하는 것 또한 나쁘지 않다.

## 결합도와 응집도

### 응집도와 결합도는 비례 or 반비례 관계일까?

응집도는 클래스에 포함된 내부 요소(상태와 행동)가 하나의 책임(목적)과 연관된 정도와 책임을 수행하기 위해서 필요한 기능들이 하나의 연관 클래스에 잘 정의가 되어 있는지를 알려주는 척도다. 

그렇기 때문에 응집도가 낮아지거나 높아진다고 하더라도 결합도에는 영향을 줄 수 없는 구조다.

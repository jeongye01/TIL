오늘은 **TypeScript 5.4 버전**에서 공식 추가된 새로운 유틸리티 타입

**`NoInfer<Type>`**에 대해 학습했다.

이 타입은 **제네릭 함수에서 타입 추론(Inference)** 의 동작을 **정밀하게 제어하기 위해** 설계되었다.

---

## 🔑 `NoInfer<Type>`의 핵심 기능

| 속성 | 설명 |
| --- | --- |
| **버전** | TypeScript 5.4에서 공식 추가됨 |
| **기능** | 포함된 타입에 대한 **타입 추론을 차단 (Blocks inferences)** |
| **특징** | 추론을 차단한다는 점을 제외하면, `NoInfer<Type>`은 **원래 타입과 완전히 동일** |

---

## 💡 예시 분석: 추론 방지 효과

다음 `createStreetLight` 함수는 제네릭 타입 `C`를 사용한다.

```tsx
function createStreetLight<C extends string>(
  colors: C[],                 // 👈 1. 이 배열을 통해 C를 추론한다.
  defaultColor?: NoInfer<C>,   // 👈 2. 이 인자에서는 C를 추론하지 못하도록 막는다.
) {
  // ...
}

```

### ✅ 1. 성공 사례 (OK)

```tsx
createStreetLight(["red", "yellow", "green"], "red");
```

- **동작**: `colors` 배열을 통해 `C`는 `"red" | "yellow" | "green"`으로 추론된다.
- **결과**: 두 번째 인자인 `"red"`는 이미 추론된 `C` 타입에 포함되므로 정상 통과된다.

---

### ❌ 2. 오류 사례 (Error)

```tsx
createStreetLight(["red", "yellow", "green"], "blue");

```

- **동작**: 동일하게 `C`는 `"red" | "yellow" | "green"`으로 추론된다.
- **결과**: `"blue"`는 **`NoInfer<C>`*가 적용된 위치이므로
    
    새로운 타입 추론을 유발하지 못하고, 이미 결정된 `C` 타입에 속하지 않아 **오류 발생**.
    

---

## 📝 결론

`NoInfer`를 사용하면, **제네릭 타입이 여러 인자에 의해 정의될 때**

특정 인자를 “타입 결정” 과정에서 **배제**하고,

대신 “이미 결정된 타입과 일치하는지만 검사”하도록 강제할 수 있다.

즉 👇

> 타입 추론을 세밀하게 통제하여, 의도치 않은 타입 확장이나 유니언 오염을 방지할 수 있다.
> 

이 기능은 **복잡한 라이브러리 함수나 프레임워크 API**를 설계할 때

**개발자의 의도를 정확히 반영**하고,

타입 안정성을 강화하는 데 매우 유용하다.

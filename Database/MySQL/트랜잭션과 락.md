잠금(LOCK)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

트랜잭션은 내부적으로 데이터의 정합성을 지키기 위해 락(Lock)을 사용한다


# Lock

## MySQL 주요 락 종류 정리표

| 락 종류 | 설명 | 사용 예시 | 자동/수동 | 언제 필요? | 위험성/주의사항 |
| --- | --- | --- | --- | --- | --- |
| **글로벌 락**(Global Lock) | DB 전체를 잠금 | `FLUSH TABLES WITH READ LOCK` | 수동 | 백업/복제용 데이터 정합성 확보 | 서비스 전체 정지 위험, 트랜잭션 오래 걸리면 락이 오래 유지됨 → 전체 시스템 마비 |
| **테이블 락**(Table Lock) | 특정 테이블 단위로 잠금 | `LOCK TABLES tbl_name WRITELOCK TABLES tbl_name READ` | 수동 | MyISAM 또는 Memory 엔진 사용 시(묵시적으로 사용됨), 다중 쿼리 동기화 |  InnoDB에서는 거의 안 씀 |
| **메타데이터 락**(MDL, Metadata Lock) | 데이터 베이스 객체(대표적으로 테이블이나 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금 | DDL 실행 시 자동 발생 (`ALTER`, `DROP`) | 자동(모든 트랜잭션에서 자동으로 기본적으로 걸립니다.) | 실행 중인 쿼리가 테이블을 참조할 때 DDL 방지 | 긴 쿼리 중 DDL 대기 → 데드락 가능 |
| **네임드 락**(Named Lock) | 이름 기반의 사용자 정의 락. 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금 | `GET_LOCK('lock_name', timeout)` | 수동 | 비즈니스 로직 동기화 (ex. 선착순 쿠폰 발급) | 자주 사용 x, 분산 환경에서는 Redis 락이 더 일반적 |

# InnoDB 스토리지 엔진 Lock

- InnoDB 스토리지 엔진의 잠금
    - 인덱스와 잠금
        - InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 잠식으로 처리된다.
        - **InnoDB는 인덱스를 기반으로 데이터를 찾기 때문에, 굳이 "데이터 자체"를 잠그는 게 아니라 "인덱스 키(또는 인덱스 범위)"에 락을 겁니다.**
        - 주의점
            - 만약 인덱스를 활용하지 못한다면
                
                ```java
                -- age에 인덱스 없음
                SELECT * FROM users WHERE age = 30 FOR UPDATE;
                -- → 전 테이블 스캔 → 모든 row에 row-level lock → 락 충돌 위험
                ```
                

# MySQL의 격리 수준

트랜잭션 격리 수준 : 한 트랜잭션이 특정 데이터를 읽거나 쓰는 중일 때, **다른 트랜잭션이 그 데이터를 읽거나 쓸 수 있는지**를 결정하는 규칙

## 4가지 트랜잭션 격리 수준 (ANSI SQL 표준)

| 격리 수준 | 허용되는 현상 | 설명 | 비고 |
| --- | --- | --- | --- |
| **READ UNCOMMITTED** | dirty read, non-repeatable read,  phantom read | 다른 트랜잭션이 아직 **커밋하지 않은 변경 사항도 읽음** |  |
| **READ COMMITTED** | non-repeatable read , phantom read  | **커밋된 데이터만 읽음**. 하지만 같은 row를 두 번 읽으면 값이 다를 수 있음 | 최소 READ COMMITED 이상의 격리 수준을 사용할 것을 권장 |
| **REPEATABLE READ** (InnoDB 기본값) | phantom read 허용 (InnoDB에서는 방지함. 따라서 굳이 Serializable을 쓸 이유가 없음) | 트랜잭션 내에서 **같은 row는 항상 동일한 값으로 보임** | MYSQL에서는 REPEATABLE READ를 주로 사용한다.  |
| **SERIALIZABLE** | 완전 격리 | 모든 트랜잭션을 순차적으로 실행하듯 처리함 (select도 잠금을 획득해야 함)→ 가장 안전하지만 성능 낮음 | 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다. (위 수준들보다 성능이 눈에 띄게 떨어질수있음) |
- Dirty Read : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- Non Repeatable Read : 한 트랜잭션 내에서 같은 row를 두 번 읽었을 때, 그 사이 다른 트랜잭션이 값을 바꿔서 결과가 달라지는 현상
- Phantom Read : 한 트랜잭션 안에서 같은 조건의 SELECT를 두 번 했을 때, 그 사이 다른 트랜잭션이 새로운 row를 INSERT해서, 두 번째 조회 결과에 “새로운 행(phantom)”이 나타나는 현상

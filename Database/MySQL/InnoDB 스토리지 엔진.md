- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하다.

## 프라이머리 키에 의한 클러스터링

- InnoDB에서는 **프라이머리 키를 기준으로 실제 데이터 레코드를 물리적으로 정렬하여 저장한다.**
- 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.

## 외래 키 지원

- 외래키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다.
- 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 자주 있는데, 그렇다 하더라도 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.

## MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것
- InnoDB는 Undo Log를 이용해 이 기능을 구현함
- 멀티 버전: 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다.

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- 이를 잠금 없는 일관된 읽기라고 한다.

## 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제 종료한다.
- 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. (강제 롤백으로 인한 MySQL 서버의 부하를 덜 유발하므로)

- innodb_table_locks :테이블 레벨의 잠금까지 감지 할 수 있음 가급적 활성화 권장
- innodb_deadlock_detect : 데드락 감지 스레드 동작 여부
- innodb_lock_wait_timeout : 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패함. (innodb_deadlock_detect가 활성화 되어있을때 설정해둘 것)

## 자동화된 장애 복구

- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다. 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료.
- MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행도미
- InnoDB에서 데이터 파일이 손상되거나  MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않긴함.
- 문제는 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈. 이때는 InnoDB 엔진이 자동으로 복구 못 할 수도 있음.
    - innodb_force_recovery :  설정값을 1부터 6까지 변경하면서 MySQL 재시작 해본다 값이 커질수록 심각한 상황.

## InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간.
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할

### 버퍼풀의 구조

- 페이지 크기 (innodb_page_size) 의 조각으로 쪼개서 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 각 조각에 저장한다.

**1. LRU 리스트 (Least Recently Used List)**

- **가장 핵심적인 리스트**
- **최근에 사용한 페이지 순서대로 정렬**
- 목적: **자주 사용하는 데이터는 메모리에 유지, 오래 안 쓴 데이터는 쫓아내기**

📌 구조

- **Old 영역**: 오래 안 쓰인 페이지 → 필요 시 교체 대상
- **Young 영역**: 최근에 자주 참조된 페이지

👉 SELECT 같은 읽기 작업 시 페이지가 버퍼 풀에 없으면 → 디스크에서 읽어와 **LRU 리스트에 넣음**

---

**2. Flush 리스트 (Flush List)**

- **더티 페이지(Dirty Page)** 들의 목록
- 더티 페이지 = 버퍼 풀에서 수정됐지만, 아직 디스크에 기록(Flush)되지 않은 페이지

📌 특징

- 수정이 일어나면 해당 페이지는 Flush 리스트에 등록
- InnoDB 백그라운드 스레드가 주기적으로 이 리스트를 따라가며 **디스크에 동기화**
- DB 크래시 시 **redo log + Flush 리스트**를 활용해 복구

---

**3. Free 리스트 (Free List)**

- **아직 아무 데이터도 담고 있지 않은 빈 페이지들**
- 새로 데이터를 읽어오거나 캐싱해야 할 때 이 리스트에서 페이지를 가져옴

📌 동작

- Free 리스트가 비면 → LRU 리스트의 Old 영역에서 오래된 페이지를 추방(evict)하여 Free로 돌림
- 즉, Free 리스트는 버퍼 풀이 **얼마나 여유가 있는지** 나타내는 지표

---

```

[Free List] → 비어있는 페이지들
     ↓ (필요 시 할당)
[LRU List] → 캐시된 페이지들 (Young / Old 영역)
     ↑ (사용 후 재배치)
[Flush List] → 수정된 페이지(Dirty Pages) 모음
     ↓ (주기적으로 디스크로 flush)

```

---

- **LRU**: 캐시 관리 (자주 쓰이는 페이지 유지)
- **Flush**: 수정됐지만 아직 디스크에 기록되지 않은 페이지 목록
- **Free**: 비어 있는 페이지들, 새 페이지 로드 시 사용

### 버퍼 풀과 리두 로그

- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더테 페이지를 디스크로 동기화함.
- 동기화 될때 발생한 체크포인트 중 가장 최근 체크포인트 지점이 LSN이 활성 리두 공간의 시작점이 된다.
- 활성 리두 공간의 마지막은 계속해서 증가하기 때문에 체크포인트와 무관하다.
- Checkpoint Age: 가장 최근 LSN과 마지막 리두 로그 엔트리의 LSN 차이

### 버퍼 풀 플러시 (Buffer Pool Flush)

- 버퍼 풀에 있는 Dirty Page(변경된 페이지)를 디스크에 반영하는 과정

| 구분 | Flush 리스트 플러시 | LRU 리스트 플러시 |
| --- | --- | --- |
| **트리거** | 체크포인트, Redo Log 공간 확보 | 버퍼 풀 Free 페이지 부족 시 |
| **대상** | Dirty Page | LRU Old 영역의 페이지 (Dirty면 flush 후 해제) |
| **목적** | 복구 단축 & Redo Log 회수 | Free 페이지 확보 |
| **순서** | LSN 순서대로 | 사용 빈도 순서(LRU) |

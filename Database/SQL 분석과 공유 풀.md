일반적인 프로그래밍 언어와 SQL의 차이는 SQL은 “처리 방법”을 기술하지 않는다는 것이다.  예를 들어 

“SELECT A FROM B WHERE C =1” 에서 어디에도 “인덱스를 사용해서”나 “풀 스캔을 하라” 와 같은 처리 방법을 기술 하지 않는다. RDBMS에서는 처리 방법을 ‘옵티 마이저’가 구성한다.

# Rule Base vs Cost Base

오라클은 SQL 처리를 규칙 기반(rule base) 또는 비용 기반(cost base) 알고리즘을 통해 처리한다. 단, 10g 부터는 규칙 기반을 지원하지 않는다. 

1. **규칙 기반 옵티마이저(Rule-Based Optimizer, RBO):** 사전에 정의된 규칙을 기반으로 실행 계획을 선택한다. 이 방식은 단순하고 예측 가능하지만, 데이터베이스의 실제 데이터 분포나 크기를 고려하지 않기 때문에 최적의 성능을 보장하지 않을 수 있다.
2. **비용 기반 옵티마이저(Cost-Based Optimizer, CBO):** 데이터의 분포, 크기, 그리고 각각의 연산 비용을 고려하여 실행 계획을 선택한다. CBO는 다양한 실행 경로의 예상 비용을 계산하고, 가장 낮은 비용을 가진 경로를 선택한다. 이 방식은 **데이터베이스의 현재 상태를 더 잘 반영**할 수 있으므로, 일반적으로 RBO보다 더 효율적인 실행 계획을 생성할 수 있다.
    
    ### **비용 추정 요소**
    
    - **디스크 I/O 비용:** 데이터를 디스크에서 읽거나 쓰는 데 소요되는 비용. 인덱스 사용 여부가 이 비용에 큰 영향을 미칠 수 있습니다.
    - **CPU 비용:** 쿼리를 처리하는 데 필요한 CPU 시간.
    
    ### **최적화 기법**
    
    - **인덱스 사용:** 적절한 인덱스를 사용하여 데이터 접근 시간을 줄일 수 있습니다.
    - **조인 순서 최적화:** 더 작은 결과 집합을 먼저 생성하여 전체 조인의 비용을 줄일 수 있습니다.
    - **서브쿼리 플랫닝:** 서브쿼리를 더 효율적인 형태로 변환할 수 있습니다.
    - **데이터 파티셔닝:** 큰 테이블을 더 작고 관리하기 쉬운 파티션으로 나누어 처리 속도를 높일 수 있습니다.

# 최적의 판단

Q. 어떤 처리 방법이 가장 좋은지(비용이 가장 적을 것인지) 판단 방법

⇒ 기본적으로 모든 처리 방법의 비용을 계산해서 비교하는 것 이외에는 방법이 없다. 간혹 DBMS가 좋지 않은 실행 계획을 선택하는 이유는 대표적으로 선택할 수 있는 실행 계획의 수가 많다는 점(모든 경우의 수를 다 계산해 볼 수 없음. 사전 정보에 의존해야 함, 오라클 12c에서 부터는 어댑티브 쿼리 최적화 도입 ⇒ 통계정보 동적 수집으로 인해 SQL 처리 속도가 느려진 경우가 있음.)과 이런 실행 계획들이 어디까지나 예측에 지나지 않다는 점 때문이다. 

# 공유 풀

공유풀은 실행 계획을 재사용하여 분석 작업을 줄이기 위한 존재라고 볼 수 있다(CPU 자원 절약).  공유 풀도 프로세스 간에 공유 되어야 하므로 버퍼 캐시와 마찬가지로 공유 메모리에 있다.

![image](https://github.com/jeongye01/TIL/assets/74299317/cec312ee-ce2c-4647-bd48-66d82798b077)


## SQL문이 같다고 판단하는 기준

오라클이 SQL 문이 같다고 판단하는 기준은 해시 알고리즘을 통해 SQL 마다 ID를 생성하는 것이다. SQL 문을 문자열로 해시 함수에 입력하고 함수에 출력된 해시 값을 SQL 문의 ID로 사용한다. 

해시 함수에서 대분자와 소문자는 다른 문자이므로 쿼리의 대문자와 소문자가 다르면 받는 해시 값도 달라진다. 

### **SQL 텍스트의 직접 비교**

- **문자열 비교:** 오라클은 SQL 문을 구성하는 문자열 자체를 비교한다. 이때 공백의 차이나 대소문자 구분(대소문자 구분 설정에 따라 다름) 등은 영향을 미칠 수 있다. 정확히 동일한 문자열로 구성된 SQL 문은 같은 것으로 간주된다.

### **바인드 변수의 사용**

- **바인드 변수:** 오라클은 바인드 변수를 사용하는 SQL 문을 효율적으로 재사용한다. 바인드 변수를 사용하면, 같은 구조의 SQL 문이 다른 데이터 값으로 실행될 때도 동일한 실행 계획을 사용할 수 있다. 예를 들어, **`SELECT * FROM employees WHERE employee_id = :id`**와 같은 쿼리는 **`:id`**에 전달되는 값에 관계없이 동일한 쿼리로 간주된다.

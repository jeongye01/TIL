SQL 튜닝은 랜덤 I/O와의 전쟁이다.

# 테이블 랜덤 엑세스

“인덱스로 검색해도 빠른데, 왜 굳이 파티셔닝을 할까?”

“인덱스로 검색하는데 왜 느릴까?”

### 인덱스 ROWID는 물리적 주소? 논리적 주소?

SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후에 테이블을 엑세스한다. 실행계획에서 “TABLE ACCESS BY INDEX ROWID”라고 표시된 부분이 여기에 해당한다. 

인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블레코드를 찾아가기 위한 주소값, 즉 ROWID를 얻으려는 데 있다. 

그렇다면 인덱스 ROWID는 물리적 주소일까, 논리적 주소일까?

인덱스 ROWID는 물리적 주소보다 논리적 주소에 가깝다. 물리적으로 직접 연결되지 않고 테이블레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문이다. 

### 메인 메모리 DB와 비교

메인메모리 DB(MMDB)는 말 그대로 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB라고 할 수 있다. 

그런데 잘 튜닝된 OLTP 성 데이터베이스 시스템이라면 버퍼캐시 히트율이 99%이상이다. 디스크를 경우하지 않고 대부분 메모리에서 읽는다는 뜻이다. 

그런데도 메인메모리 DB만큼 빠르지는 않다. 특히 대량 데이터를 인덱스로 엑세스할때는 엄청난 차이가 난다. 

메인메모리DB의 인덱스는 오라클 처럼 디스크 상의 주소정보를 갖는게 아니라 메모리상의 주소정보, 즉 포인터를 갖는다. 따라서 인덱스를 경유해 테이블을 엑세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다. 

오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조다. 메모리 주소정보가 아닌 디스크 주소정보를 이용해(DBA) 해시 알고리즘으로 버퍼 블록을 찾아간다. 

데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야 한다. 동시 액세스가 심할 때는 캐시 버퍼 체인래치와 버퍼 Lock에 대한 경합까지 발생한다. 동시 액세스가 심할때는 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다. 이처럼 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다.

# 인덱스 클러스터링 팩터

:특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 예를 들어 거주지역=”제주”에 해당하는 고객 데이터가 물리적으로 근접해 있으면 흩어져 있을때보다 데이터를 찾는 속도가 빠르다.  이는 테이블 액세스량에 비해 물리적 I/O가 적게 발생함을 의미한다. 

# 인덱스 손익분기점

<img width="567" alt="image" src="https://github.com/jeongye01/TIL/assets/74299317/d5f6f6ff-f802-4511-8e6b-c395f57e26c5">


인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다. 따라서 읽어야할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다. Index Range Scan에 의한 테이블 엑세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 부른다.

Table Full Scan은 성능이 일정하다. 1000만건을 조회하든, 10만건을 조회하든, 차이가 거의 없다. 

인덱스를 이용해 테이블을 엑세스 할때는 전체 1000만건 중 몇건을 추출하느냐에 따라 성능이 크게 달라진다. 테이블 랜덤 엑세스 때문이다. 

인덱스를 이용한 테이블 엑세스가 Table Full Scan 보다 더 느려지게 만드는 가장 핵심적인 두 가지 요인은 다음과 같다.

- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
- Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 Single Block I/O 방식이다.

이런 요인에 의해, 인덱스 손익 분기점은 보통 5~20%의 낮은 수준에서 결정된다. 그리고 CF에 따라 크게 달라진다. 인덱스 CF가 나쁘면 5% 미만에서 결정되며, 심할때는(BCHR이 매우 안 좋을 때) 1% 미만으로 낮아진다. 반대로 CF가 아주 좋을때 90% 수준까지 올라가기도 한다,

### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다. 조인도 대부분 NL 방식을 사용한다. 

반면, 대량 데이터를 읽고 갱신하는 배치(Batch) 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다. 대량 데이터를 빠르게 처리하려면 Full Scan과 해시 조인이 유리하다.

그러나 초대용량 테이블을 Full Scan 하면 상당히 오래 기다려야 하고 시스템에 주는 부담도 적지 않다. 따라서 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝 요소이고, 병렬처리까지 더할 수 있으면 금상첨화다.

# 인덱스 컬럼 추가

테이블 엑세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.

기존 인덱스에 컬럼을 추가하는 것만으로 큰 효과를 얻을 수 있다. 인덱스 스캔량은 줄지 않지만, 테이블 랜덤 엑세스 횟수를 줄여주기 때문이다.

# 인덱스만 읽고 처리

쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 엑세스가 아예 발생하지 않게 하는 방법을 고려해 볼수 있다. 참고로, 인덱스만 읽어서 처리하는 쿼리를 Covered 쿼리라고 부르며, 그 쿼리에 사용된 인덱스를 Covered 인덱스라고 부른다, 

이 방법이 효과는 매우 좋지만, 추가해야 할 컬럼이 많아 실제 적용하기 곤란한 경우도 많다.

### Include 인덱스

: 순전히 테이블 랜덤 엑세스를 줄이는 용도로 개발됐다. 아직 Oracle에는 없으며 SQL Server 2005 버전에 추가 되었다. 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능이다.

# 인덱스 구조 테이블

- IOT(Index-Organized Table) : 랜덤 액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성. 테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 IOT는 그 자리에 테이블 데이터를 갖는다. 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장하고 있다. IOT에서는 인덱스 리프 블록이 곧 데이터 블록이다. IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하낟,

# 클러스터 테이블

### 인덱스 클러스터 테이블

클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조다. 한 블록에 모두 담을수 없을때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다. 심지어 여러 테이블 레코드를 같은 블록에 저장할 수도 있는데 이를 다중 테이블 클러스터라고 부른다. 일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유할 수 없음. 

오라클 클러스터는 키 값이 같은 데이터를 같은 공간에 저장해 둘 뿐, IOT나 SQL Server의 클러스터형 인덱스처럼 정렬하지는 않는다. 

클러스터 인덱스도 일반 B+Tree인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다는 점이 다르다. 즉  클러스터 인덱스는 테이블 레코드와 1:M 관계를 가지며 클러스터 인덱스의 키 값은 항상 유니크하다.

### 해시 클러스터 테이블

인덱스를 사용하지 않고 

해시 알고리즘을 사용해 클러스터를 찾아간다.

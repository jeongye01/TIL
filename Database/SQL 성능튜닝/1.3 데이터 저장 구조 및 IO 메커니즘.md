I/O 튜닝이 곧 SQL 이라고 해도 과언이 아니다.

## SQL 이 느린이유

SQL이 느린이유는 십중팔구 디스크 I/O 때문이다.

I/O = 잠(sleep) 이라고 할 수 있다. 

OS또는 I/O 서브시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다. 

정해진 OS함수를 호출하고 CPU를 반환한 채 알람을 설정하고 대기 큐에서 잠을자는 것이다. 

## 데이터베이스 저장 구조

<img width="453" alt="image" src="https://github.com/jeongye01/TIL/assets/74299317/fdee2885-7c58-4a04-a419-ce3dffad0a68">


- 테이블스페이스 : 데이터를 저장하려면 먼저 테이블스페이스를 생성해야 한다. 테이블스페이스는 세그먼트를 담는 컨테이너로서, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성된다.
- 세그먼트 : 여러 익스텐트로 구성된다. 파티션 구조가 아니라면 테이블도 하나의 세그먼트, 인덱스도 하나의 세그먼트다. 테이블 또는 인덱스가 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 별도 공간에 값을 저장한다.
- 익스텐트 : 공간을 확장하는 단위다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족하면 해당 오브젝트가 속한 테이블 스페이스로부터 익스텐트를 추가로 할당받는다. 익스텐트는 연속된 블록들의 집합이기도 하다.테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트,테이블, 인덱스를 생성할 때 데이터를 어떤 테이블스페이스에 저장할지 지정한다.
- 블록: 최소 IO단위.**데이터를 읽고 쓰는 단위**. 한 블록은 하나의 테이블이 독점한다. 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다.

세그먼트 공간이 부족해지면 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 이때 세그먼트에 할당된 모든 익스텐트가 같은 데이터 파일에 위치하지 않을 수 있다. 서로 다른 데이터파일에 위치할 가능성이 더 높다. (파일 경합을 줄이기 위함.) 

### DBA

:(Data Block Address) . 모든 데이터 블록은 디스크 상에서 몇번 데이터파일의 몇번째 블록인지를 나타내는 자신만의 고유 주소값을 가진다. 

## 블록 단위 I/O.

데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다. 테이블 뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다. 

## 시퀀셜 엑세스 vs 랜덤 엑세스

- 시퀀셜(Sequential) 엑세스 :  논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식.
    - 인덱스 리프 블록 : 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있다. 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식을 가진다.
    - 테이블 블록: 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵(map)으로 관리한다. 익스텐트 맵은 각 익스텐트의 첫 번째 블록 주소 값을 갖는다. 읽어야할 익스텐트 목록을 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 Full Table Scan이다.
- 랜덤(random) 엑세스 : 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

## 논리적 I/O vs 물리적 I/O.

### DB 버퍼캐시

모든 DBMS에 데이터 캐싱 메커니즘이 필수다.

### 논리적 I/O vs 물리적 I/O.

- 논리적 블록 I/O : SQL을 수행하면서 읽은 총 블록 I/O.   Direct Path Read방식으로 읽는 경우를 제외하면 모든 블록은 DB버퍼 캐시를 경유하므로 경유하므로 메모리 I/O 가 곧 논리적 I/O라고 할 수 있다.
- 물리적 블록 I/O: 디스크에서 발생한 총 블록 I/O. 물리적 I/O는 SQL을 실행할때마다 다르다. 연속해서 실행하면 DB버퍼 캐시에서 해당 데이터 블록의 점유율이 점점 높아지기 때문이다.

### 버퍼 캐시 히트율

BCHR = (버퍼 캐시에서 찾은 블록 수 / 총 읽은 블록 수) * 100

어플리케이션 특성에 따라 다르지만, 온라인 트랜잭션을 주로 처리하는 어플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다. 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로 열심히 튜닝하면 99%는 결코 달성하기 어려운 수치가 아니다.

실제로 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄이기 위한 노력을 해야 한다. 논리적 I/O와 물리적 I/O는 비례관계인데, 물리적 관계는 BCHR에 의해 결정된다. BCHR시스템 상황에 따라 달라지므로 결국 SQL 성능을 높이기 위해 할수 있는 일은 논리적 I/O를 줄이는 일 뿐이다. 

## Single Block I/O vs Mutiblock I/O.

- Single Block I/O : 한번에 한 블록씩 요청해서 메모리에 적재하는 방식. 인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O 방식을 사용한다. 인덱스는 소량의 데이터를 읽을때 주로 사용하므로 이 방식이 효율적이다.
- Mutiblock I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식. 많은 데이터 블록을 읽을 때는 이 방식이 효율적이다. 테이블 전체를 스캔할때 이 방식을 사용한다.

## Table Full Scan vs Index Range Scan

- Table Full Scan : 테이블 전체 스캔
- Index Range Scan : 인덱스를 이용한 테이블 엑세스

일반적으로 Table Full Scan은 피해야 한다는 많은 개발자의 인식과 달리 인덱스가 SQL 성능을 떨어뜨리는 경우도 상당히 많다. 한번에 많은 데이터를 처리하는 집계용 SQL과 배치 프로그램이 특히 그렇다. 

Index Range Scan을 통한 테이블 엑세스는 렌덤 액세스와 Single Block I/O 방식으로 디스크 블록을 읽는다, 캐시에서 블록을 못 찾으면, 레코드 하나를 읽기 위해 매번 잠을 자는 I/O 매커니즘이다. 따라서 많은 데이터를 읽을때는 Table Full Scan보다 불리하다.

# ACID

### A(Atomicity):원자성

트랜잭션에 포함된 데이터의 변경은 ‘전부 OK’ 이거나 ‘모두 NG’라는 ‘all or noting’을 말한다.

DBMS는  수행중인 트랜잭션에서 데이터를 일부만 변경하고 나머지는 수행하지 않은 채 커밋할 수 없다.

### C(Consistency):일관성

트랜잭션에 의해 데이터 간의 일관성이 어긋나서는 안된다는 의미. 일관성이 어긋나는 예로는 고객 개인의 데이터는 변경되었는데, 고객 전체의 통계 데이터는 변경되지 않았다 와 같은 것들이 있다.

### I(Isolation):고립성

트랜잭션끼리는 고립되고 독립되어 있다는 의미. 어떤 트랜잭션을 단독으로 실행했거나 다른 트랜잭션과 동시에 실행했더라도 결과는 같아야 한다. 단, DBMS에 따라서는 어느 정도 고립시킬 것인가에 대한 레벨을 선택할 수 있음.

### D(Durability):지속성

커밋한 트랜잭션은 장애가 발생하더라도 데이터는 반드시 복구되어야 한다. 

# 지속성 구현

상용 RDBMS 대부분은 로그(변경 로그)를 채용하여 성능과 지속성을 양립시킬 수 있게 하였다. 오라클은 REDO로그를 통해서 성능과 지속성을 확보했다. 

# REDO,UNDO

- roll-forward : REDO 로그 를 사용해 과거의 데이터를 최신 데이터 쪽으로 흐르게 하는 것
- rollback : UNDO 로그의 정보를 사용해서 변경을 취소.

- SCN(System Change Number) : 오라클 내부의 시간(정확히는 시간이 아닌 번호). 복구등에 사용된다.

# REDO의 구조

데이터의 변경은 캐시에서 이루어진다. 그때 REDO 로그(변경 이력 데이터)라고 불리는 로그 데이터가 생성된다.  

오라클은 REDO로그를 커밋이 발생하기 전에 디스크에 기록하는 방식으로 지속성을 구현했다. 단 성능에 단점이 있으므로 커밋하는 시점에 연동해서 데이터 블록을 기록하려고는 하지 않는다. 

REDO 로그용 메모리로서 REDO 버퍼가 공유 메모리에 존재한다. REDO 로그를 디스크에 REDO 로그 파일로 기록하는 것은 LGWR 이라고 불리는 프로세스가 수행한다. REDO로그 파일은 개수가 한정(일반적으론 한 세트에 3개)되어 있으며, 크기도 제한되어 있으므로 REDO 로그를 계속 보관하고 있을 수는 없다.

그래서 아카이브 REDO 로그 파일이라는 오랫동안 REDO 로그를 보관해두기 위한 파일이 존재한다. REDO 로그 파일은 REDO 로그의 일시적인 보관창고이며, 아카이브 REDO 로그 파일이 오랜시간 보관할 수 있는 본격적인 보관창고이다. 

REDO 로그 파일은 매우 중요한 파일이므로 반드시 다중화해야 한다. 일반적으로 REDO 로그 그룹을 여러 개의 세트로 만들고, 그룹 안에 멤버(REDO 로그 파일)를 추가한다. 

프로세스 수준에서, 서버 프로세스는 커밋했을 때 LGWR 프로세스에 REDO 로그를 기록하도록 요청한다. 요청을 받은 LGWR 프로세스는 REDO 로그를 REDO 로그 파일에 기록한다. 기록이 LGWR 프로세스가 서버 프로세스 기록이 끝났다고 통보한다. 그 후에 서버 프로세스는 커밋이 끝난 것을 오라클 클라이언트에게 통보한다. 

# UNDO의 구조

데이터가 변경되면 UNDO 정보가 생성되며, 생성된 UNDO 정보는 세그먼트에 보관된다. (테이블스페이스들 중 어딘가에 보관된다.) UNDO가 보관ㄷ뇌는 테이블 스페이스를 UNDO 테이블 스페이스라고 부른다. 

- UNDO_RETENTION : UNDO 유지시간을 설정할 수 있다. UNDO 정보를 커밋한 이후에도 일정 시간 유지하고 싶을때 유용한 파라미터 이다.

![image](https://github.com/jeongye01/TIL/assets/74299317/2dc4b85f-82f8-4845-b431-08ce8b8a857f)


# 여러 상황에서 REDO와 UNDO의 동작

### 롤백할 때의 동작

롤백이 수행된다면 UNDO에 보관된 정보를 사용해서 데이터를 원래의 값으로 되돌린다

서버 프로세스가 비정상적으로 종료했을때도 PMON이라고 불리는 백그라운드 프로세스가 정기적으로 체크를 수행하며, 종료된 서버 프로세스를 정리한다. 또한, SMON이라고 불리는 백그라운드 프로세스가 데이터를 트랜잭션 시작 전의 상태로 되돌려준다.

### 읽기 일관성에 동반되는 동작

읽기 일관성은 데이터가 변경된 시점을 확인하고, 검색을 시작한 후에 변경된 데이터일 때는 UNDO를 사용해서 과거의 데이터를 메모리 위에 재현한다.

![image](https://github.com/jeongye01/TIL/assets/74299317/e2265ff2-55c8-45dd-b979-b2eba3ab392d)


### 커밋되지 않은 데이터를 읽어올 때의 동작

오라클에서는 기본적으로 고립성을 지키기 위해 read committed 동작을 하도록 설정되어 있다. 

커밋되지 않은 다른 세션의 데이터를 읽어올 때도 읽기 일관성과 마찬가지로 변경되기 이전의 데이터를 보여주며, 필요할 때는 UNDO를 사용해 과거의 데이터를 메모리 위에 재현하는 방식으로 구현한다.

![image](https://github.com/jeongye01/TIL/assets/74299317/d1ffa615-43ae-477f-9687-8dc8a76a232e)


### ORA-1555 에러가 발생했을때의 동작

이 에러는 ‘과거의 데이터를 보려 했으나 필요한 정보가 이미 없어졌다’라는 것을 의미한다. 

![image](https://github.com/jeongye01/TIL/assets/74299317/92e331df-5327-4dbc-b0b1-bfca800a3289)


ORA-1555가 발생할 때는 우선 undo_retention이나 UNDO 테이블스페이스의 크기를 튜닝할 것을 컴토하며, 장시간 수행되는 SQL문으로 인해 발생한다면 애플리케이션의 개선도 필요할 수 있다.

### 체크포인트의 동작

체크포인트는 메모리의 데이터를 디스크와 동기화하는 작업을 말한다. DBWR이 데이터를 메모리에서 디스크로 기록한다.

REDO로그와 예전 데이터가 있다면 롤 포워드는 할 수 있지만, 너무 오래된 데이터를 기점으로 롤 포워드하려면 많은 시간이 필요하다. 따라서 체크포인트를 통해 데이터를 디스크에 정기적으로 기록하고 롤 포워드에 걸리는 시간을 단축한다. 

### 인스턴스 복구 시의 동작

커밋하지 않은 트랜잭션은 REDO 로그에도 커밋 정보가 존재하지 않는다. 따라서 UNDO 정보를 사용해서 커밋정보가 존재하지 않은 트랜잭션들을 구분해내어 롤백 처리를 수행한다. 이런부분에서 오라클이 원자성을 제대로 지키고 있음을 알 수 있다.
